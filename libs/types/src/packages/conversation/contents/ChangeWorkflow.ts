export const ChangeWorkflow = {
  description: 'Applies a requested changeset immediately to the document.',
  name: 'Change Workflow',
  request: {
    description: 'Expected request payload for this workflow.',
    type: {
      blueId: '9KDfK6k1HBAyHckj5VuWXFMLkgY5cJBESKT4eoq1bnrw',
    },
  },
  steps: {
    items: [
      {
        code: {
          type: {
            blueId: 'DLRQwz7MQeCrzjy9bohPNwtCxKEBbKaMK65KBrwjfG6K',
          },
          value:
            "const issues = [];\n\nconst request = event.message.request || {};\n\nconst changeDescription = request.changeDescription;\nconst rawChangeset = request.changeset;\nconst rawSectionChanges = request.sectionChanges;\nconst requestSectionChanges = rawSectionChanges || {};\n\nconst toText = (value) => {\n  const raw = value && value.value ? value.value : value;\n  return raw && raw.trim ? raw.trim() : '';\n};\nconst asList = (value) => Array.isArray(value) ? value : [];\nconst hasType = (value) => value && value.type;\nconst escapePointer = (value) => {\n  const text = toText(value);\n  return text.split('~').join('~0').split('/').join('~1');\n};\nconst requestChangeset = asList(rawChangeset);\n\nconst uniqueKeys = (values, label) => {\n  const seen = new Set();\n  const output = [];\n  for (const value of values) {\n    const key = toText(value);\n    if (!key) {\n      issues.push(label + ' contains invalid key');\n      continue;\n    }\n    if (seen.has(key)) {\n      issues.push(label + ' contains duplicate key: ' + key);\n      continue;\n    }\n    seen.add(key);\n    output.push(key);\n  }\n  return output;\n};\n\nconst sameStringSet = (left, right) => {\n  if (left.length !== right.length) return false;\n  const set = new Set(left);\n  if (set.size !== right.length) return false;\n  for (const value of right) {\n    if (!set.has(value)) return false;\n  }\n  return true;\n};\n\nconst contracts = Object(document('/contracts') || {});\n\nconst isDocumentSection = (contract) =>\n  !!contract && Array.isArray(contract.relatedContracts);\n\nconst isContractsChangePolicy = (contract) => {\n  if (!contract) return false;\n  return 'requireSectionChanges' in contract;\n};\n\nconst findPolicy = () => {\n  for (const key of Object.keys(contracts)) {\n    const contract = contracts[key];\n    if (isContractsChangePolicy(contract)) {\n      return contract;\n    }\n  }\n  return null;\n};\n\nconst policy = findPolicy();\nconst policyEnabled = !!policy && policy.requireSectionChanges !== false;\n\nif (!toText(changeDescription)) {\n  issues.push('changeDescription is missing');\n}\n\nconst hasChangeset = !!rawChangeset;\nconst hasSectionChanges = !!rawSectionChanges;\n\nif (!hasChangeset && !hasSectionChanges) {\n  issues.push('changeset or sectionChanges is required');\n}\n\nconst isContractsPath = (path) => {\n  const value = toText(path);\n  return value === '/contracts' || value.startsWith('/contracts/');\n};\nif (policyEnabled && hasChangeset) {\n  for (const entry of requestChangeset) {\n    if (entry && isContractsPath(entry.path)) {\n      issues.push('changeset cannot modify /contracts when Contracts Change Policy is enabled');\n      break;\n    }\n  }\n}\nconst isProposedChangePath = (path) =>\n  toText(path).startsWith('/proposedChange');\nif (hasChangeset) {\n  for (const entry of requestChangeset) {\n    if (entry && isProposedChangePath(entry.path)) {\n      issues.push('changeset cannot modify /proposedChange');\n      break;\n    }\n  }\n}\n\nconst existingSections = {};\nfor (const key of Object.keys(contracts)) {\n  const contract = contracts[key];\n  if (isDocumentSection(contract)) {\n    existingSections[key] = contract;\n  }\n}\n\nconst contractIndex = {};\nfor (const sectionKey of Object.keys(existingSections)) {\n  const section = existingSections[sectionKey];\n  const related = asList(section.relatedContracts);\n  for (const relatedKey of related) {\n    const contractKey = toText(relatedKey);\n    if (!contractKey) continue;\n    if (contractIndex[contractKey] && contractIndex[contractKey] !== sectionKey) {\n      contractIndex[contractKey] = null;\n    } else if (!contractIndex[contractKey]) {\n      contractIndex[contractKey] = sectionKey;\n    }\n  }\n}\n\nconst normalizeSectionDefinition = (sectionDef, label) => {\n  if (!sectionDef) {\n    issues.push(label + ' entry must be an object');\n    return null;\n  }\n  const sectionKey = toText(sectionDef.sectionKey);\n  if (!sectionKey) {\n    issues.push(label + ' sectionKey is missing');\n    return null;\n  }\n  const section = sectionDef.section;\n  if (!section) {\n    issues.push(label + ' section is missing');\n    return null;\n  }\n\n  const contractsMap = sectionDef.contracts || {};\n  const contractDefs = [];\n  const contractKeys = [];\n  for (const [rawKey, contract] of Object.entries(contractsMap)) {\n    const key = toText(rawKey);\n    if (!key) {\n      issues.push(label + ' contract key is missing');\n      continue;\n    }\n    if (!contract) {\n      issues.push(label + ' contract ' + key + ' is missing or invalid');\n      continue;\n    }\n    if (!hasType(contract)) {\n      issues.push(label + ' contract ' + key + ' is missing type');\n    }\n    contractDefs.push({ key, contract });\n    contractKeys.push(key);\n  }\n\n  if (!hasType(section)) {\n    issues.push(label + ' section ' + sectionKey + ' is missing type');\n  }\n\n  const related = section.relatedContracts\n    ? uniqueKeys(asList(section.relatedContracts), label + ' section ' + sectionKey + ' relatedContracts')\n    : null;\n  if (related && !sameStringSet(related, contractKeys)) {\n    issues.push(label + ' section ' + sectionKey + ' relatedContracts must match contracts');\n  }\n\n  const normalizedRelated = related || contractKeys;\n  const normalizedSection = Object.assign({}, section, {\n    type: 'Conversation/Document Section',\n    relatedContracts: normalizedRelated\n  });\n\n  return {\n    sectionKey,\n    section: normalizedSection,\n    contractDefs,\n    contractKeys\n  };\n};\n\nconst sectionChangeset = [];\nconst seenSectionKeys = new Set();\nconst seenContractKeys = new Set();\n\nconst addList = asList(requestSectionChanges.add);\nconst modifyList = asList(requestSectionChanges.modify);\nconst removeList = asList(requestSectionChanges.remove);\n\nfor (const entry of addList) {\n  const normalized = normalizeSectionDefinition(entry, 'sectionChanges.add');\n  if (!normalized) continue;\n  const sectionKey = normalized.sectionKey;\n  if (seenSectionKeys.has(sectionKey)) {\n    issues.push('section key duplicated in sectionChanges: ' + sectionKey);\n    continue;\n  }\n  seenSectionKeys.add(sectionKey);\n\n  if (contracts[sectionKey]) {\n    issues.push('section key already exists at /contracts/' + sectionKey);\n  }\n\n  for (const contractKey of normalized.contractKeys) {\n    if (seenContractKeys.has(contractKey)) {\n      issues.push('contract key used by multiple sections in request: ' + contractKey);\n      continue;\n    }\n    seenContractKeys.add(contractKey);\n    if (contracts[contractKey]) {\n      issues.push('contract key already exists at /contracts/' + contractKey);\n    }\n  }\n\n  for (const contractDef of normalized.contractDefs) {\n    sectionChangeset.push({\n      op: 'add',\n      path: '/contracts/' + escapePointer(contractDef.key),\n      val: contractDef.contract\n    });\n  }\n  sectionChangeset.push({\n    op: 'add',\n    path: '/contracts/' + escapePointer(sectionKey),\n    val: normalized.section\n  });\n}\n\nfor (const entry of modifyList) {\n  const normalized = normalizeSectionDefinition(entry, 'sectionChanges.modify');\n  if (!normalized) continue;\n  const sectionKey = normalized.sectionKey;\n  if (seenSectionKeys.has(sectionKey)) {\n    issues.push('section key duplicated in sectionChanges: ' + sectionKey);\n    continue;\n  }\n  seenSectionKeys.add(sectionKey);\n\n  const existingSection = contracts[sectionKey];\n  if (!existingSection) {\n    issues.push('section key does not exist at /contracts/' + sectionKey);\n  } else if (!isDocumentSection(existingSection)) {\n    issues.push('existing section at /contracts/' + sectionKey + ' is not a Document Section');\n  }\n\n  const existingRelated =\n    existingSection && existingSection.relatedContracts\n      ? asList(existingSection.relatedContracts)\n      : [];\n  if (existingSection && !existingSection.relatedContracts) {\n    issues.push('existing section ' + sectionKey + ' is missing relatedContracts');\n  }\n\n  for (const contractKey of normalized.contractKeys) {\n    if (seenContractKeys.has(contractKey)) {\n      issues.push('contract key used by multiple sections in request: ' + contractKey);\n      continue;\n    }\n    seenContractKeys.add(contractKey);\n    if (contractIndex[contractKey] && contractIndex[contractKey] !== sectionKey) {\n      issues.push('contract key ' + contractKey + ' is linked to another section');\n    }\n  }\n\n  for (const contractDef of normalized.contractDefs) {\n    const op = contracts[contractDef.key] ? 'replace' : 'add';\n    sectionChangeset.push({\n      op,\n      path: '/contracts/' + escapePointer(contractDef.key),\n      val: contractDef.contract\n    });\n  }\n\n  const toRemove = uniqueKeys(existingRelated, 'sectionChanges.modify remove list').filter(\n    (key) => !normalized.contractKeys.includes(key)\n  );\n  for (const contractKey of toRemove) {\n    if (contractIndex[contractKey] && contractIndex[contractKey] !== sectionKey) {\n      issues.push('contract key ' + contractKey + ' is linked to another section');\n      continue;\n    }\n    sectionChangeset.push({\n      op: 'remove',\n      path: '/contracts/' + escapePointer(contractKey)\n    });\n  }\n\n  sectionChangeset.push({\n    op: 'replace',\n    path: '/contracts/' + escapePointer(sectionKey),\n    val: normalized.section\n  });\n}\n\nconst removeKeys = uniqueKeys(removeList, 'sectionChanges.remove');\nfor (const sectionKey of removeKeys) {\n  if (seenSectionKeys.has(sectionKey)) {\n    issues.push('section key duplicated in sectionChanges: ' + sectionKey);\n    continue;\n  }\n  seenSectionKeys.add(sectionKey);\n\n  const existingSection = contracts[sectionKey];\n  if (!existingSection) {\n    issues.push('section key does not exist at /contracts/' + sectionKey);\n    continue;\n  }\n  if (!isDocumentSection(existingSection)) {\n    issues.push('existing section at /contracts/' + sectionKey + ' is not a Document Section');\n    continue;\n  }\n\n  const related = existingSection.relatedContracts\n    ? uniqueKeys(asList(existingSection.relatedContracts), 'sectionChanges.remove relatedContracts')\n    : [];\n  if (!existingSection.relatedContracts) {\n    issues.push('existing section ' + sectionKey + ' is missing relatedContracts');\n  }\n\n  for (const contractKey of related) {\n    if (contractIndex[contractKey] && contractIndex[contractKey] !== sectionKey) {\n      issues.push('contract key ' + contractKey + ' is linked to another section');\n      continue;\n    }\n    sectionChangeset.push({\n      op: 'remove',\n      path: '/contracts/' + escapePointer(contractKey)\n    });\n  }\n  sectionChangeset.push({\n    op: 'remove',\n    path: '/contracts/' + escapePointer(sectionKey)\n  });\n}\nconst combinedChangeset = sectionChangeset.concat(hasChangeset ? requestChangeset : []);\n\nif (combinedChangeset.length === 0) {\n  issues.push('no changes provided');\n}\n\nif (issues.length > 0) {\n  return {\n    changeset: [],\n    events: [\n      {\n        type: \"Conversation/Proposed Change Invalid\",\n        reason: issues.join('; ')\n      }\n    ]\n  }\n}\n\nreturn {\n  changeset: combinedChangeset\n};\n",
        },
        name: 'Prepare',
        type: {
          blueId: 'ExZxT61PSpWHpEAtP2WKMXXqxEYN7Z13j7Zv36Dp99kS',
        },
      },
      {
        changeset: {
          type: {
            blueId: 'DLRQwz7MQeCrzjy9bohPNwtCxKEBbKaMK65KBrwjfG6K',
          },
          value: '${steps.Prepare.changeset}',
        },
        name: 'Apply',
        type: {
          blueId: 'FtHZJzH4hqAoGxFBjsmy1svfT4BwEBB4aHpFSZycZLLa',
        },
      },
    ],
  },
  type: {
    blueId: 'CGdxkNjPcsdescqLPz6SNLsMyak6demQQr7RoKNHbCyv',
  },
} as const;
